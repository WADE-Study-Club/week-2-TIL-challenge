# 운영 체제 OS ?

[운영체제 수업](http://www.kocw.net/home/search/kemView.do?kemId=1046323)

## 운영체제 역할

### 하드웨어를 효율적으로 관리하는 역할을 한다.

(컴퓨터 시스템의 자원을 효율적으로 관리한다.)

## 자원이란?

1. CPU 메모리 입출력 장치 등 ( resource ) 효율적 관리 -> 운영체제 가장 큰 목적
CPU 메모리 이미 들어가있는 하드웨어를 가지고 최대한의 성능을 내도록 해주는 역할을 한다.
- 주어진 자원 최대한 성능을 내도록 하는 것!
- 특정 프로그램이나 특정 사용자가 차별받는 상황이 생길 수 있는데 사용자간 형평성 있는 자원 분배를 원칙으로 한다.
- 프로세스, 파일, 메시지 등을 관리
- 사용자 및 운영체제 자신을 보호

 2.   사용자의 편리성을 고려하여 컴퓨터를 사용할 수 있도록 해주도록  돕는 목적

- 컴퓨터 시스템을 편리하게 사용 할 수 있는 환경을 제공
- 운영체제는 동시 사용자/ 프로그램들이 각각 독자적 컴퓨터에서 수행되는 것 같은 환상을 제공
- 하드웨어를 직접 다루는 복잡한 부분을 운영체제가 대행


실행중인 프로그램들에 메모리 공간을 적절히 분배

# 운영체제 분류

---

---

## 동시작업이 가능 여부

- 단일 작업 (single tasking)

MS-DOS ? 하나의 작업만 처리 

- 다중 작업 (multi tasking)

동시에 두개 이상의 작업 처리

UNIX, MS Windows 등에서는 한 명령의 수행이 끝나기 전에 다른 명령이나 프로그램을 수행할 수 있음

## 사용자 수

- 단일 사용자 (single user)
- 다중 사용자 (multi user)

UNIX, NT server ( 다중 사용이므로 보안, 형평성 문제 처리해야함 )

## 처리 방식

- 일괄 처리 ( batch processing )

작업 요청의 일정량을 모아서 한꺼번에 처리

작업이 완전 종료될 때까지 기다려야 함

초기 Punch Card 처리 시스템

OMR 마킹 처리 시스템 같은?

- 시분할 ( time sharing )

여러 작업을 수행할 때 컴퓨터 처리 능력을 일정한 단위로 분할하여 사용

일괄 처리 시스템에 비해 짦은 응답 시간을 가짐

interactive 한 방식 ( 100ms )

사용자가 늘어나면 응답시간이 늘어날 수 있음...!

( 현재 컴퓨터 )

- 실시간 ( Realtime OS )

정해진 시간 안에 어떤 일이 반드시 종료됨이 보장!! ( 시분할과 다른점) 반드시 정해진 시간 안에 종료됨

( 원자로. 공장제어 / 미사일 제어 / 반도체 장비 / 로보트 제어 )

실시간 시스템의 개념 확장 ( 삼성 반도체 공장 정전 사건 ? )

파이프라인 공정 ( deadline ) 이 있는데 한달만에 나와야 한다.

공정간 기간이 정해져 있기 때문에 한 공정에서 느려지게 되면 전체 공정에 문제가 생기게 된다.

( 납품에 문제가 생김 )

- 실시간 시스템 개념 확장
    - Hard realtime system ( 미사일 제어, 원자로 ? )
    - Soft realtime system ( 영화 프레임 )

시분할 시스템 에 대해 주로 다룰 예정이다.

다중 작업 / 다중 사용자 시분할 방식

## 용어 정리

Multitasking - 

Mutiprogramming - 메모리에 여러 프로그램이 올라감.

Time sharing - CPU의 시간을 분할하여 나누어 쓴다는 의미

Multiprocess

Multiprocessor  - ( 다중 처리기 )

- 하나의 컴퓨터에 CPU ( processor ) 가 여러 개 붙어 있음을 의미
- 범용 ( CPU ) 단일 컴퓨터만 다룸

## 운영체제의 예

## 유닉스

- 다중 사용자 고려
- 서버를 위한 OS
- 소스 코드 공개

유닉스를 만들기 위해 C언어를 개발하여 코드 대부분을 C언어로 작성

대부분의 커널 코드가 C언어로 작성되어 있다.

하드웨어를 직접적으로 다루면서 사람하고도 가까움

- 프로그램 개발에 용이
- 다양한 버전이 존재
- 높은 이식성이 있다. ( portable )

특정 기계어와 독립된 C언어로 작성되어 다른 기계에서도 돌아가겠끔 설계되어 있다.

- 최소한의 커널 구조

리눅스 - 안드로이드 커널 ( 리눅스를 사용함 )

## MS Window

**DOS**

단일 사용자 고려 ( MS_DOS 부터 시작 )

메모리 관리 능력의 한계 ( 주 기억 장치 : 640KB )

**MS Windows**

MS사의 다중 작업용 GUI 기반 운영 체제

네트워크 환경 강화

풍부한 지원 소프트웨어

APPLE IOS 등 여러 운영체제가 있다.

## 운영체제의 구조

### CPU 스케줄링 ( 누구한테 CPU를 줄까 ? )


선착순 처리 ( 일반적인 방법 ) 이 아닌 여러 스케줄링 방식이 있다.

먼저 온 순서대로 처리 

단점? 업무 1시간 걸리는 경우 순차 처리의 경우는 뒷 사람이 계속 기다려야 하는 큰 단점이 존재

길게 CPU를 쓰려고 하는 프로그램보다는 짧게 쓰는 프로그램에 우선 스케줄링 부여

현대 CPU 빠르게 그냥 여러번 줬다 뺏었다를 반복하는게 더 효율적

### 메모리 관리

- 한정된 메모리를 어떻게 쪼개어 쓰지?

무조건 n분의 1로 나누는 것보다 몰아주는 것이 좋을 때가 있다

working Set

- 꽉 찼을 때 어떤 걸 쫓아내야 하는가?

CPU 에서 자주 사용하는 것 제외하고 쫓아내야한다.

가까운 미래에 사용가능성이 높은지 낮은지 이전 사용량을 확률적으로 계산하여 메모리에 올려주고 적은 사용량은 쫓아낸다.

### 파일 관리

- 디스크에 파일을 어떻게 보관하지?
- 디스크 스케줄링

디스크는 헤드가 움직이면 처리 ( 헤드와 가까운 공간 처리를 먼저하면서 이동을 줄여 효율적으로 처리 )

어떻게 움직임을 최소화하여 효율적으로 처리할 수 있을지

## IO 입출력 관리

- 각기 다른 입출력 장치와 컴퓨터 간에 어떻게 정보를 주고 받게 하지?
- 인터럽트?

### 프로세스 관리


### 그외


CPU / 메모리 / IO device

하드 디스크 보조 기억 장치 - I/O 동시 수행

키보드 / 마우스 - Input

모니터 - Output


device controller 가 작은 CPU 역할을 하고 local buffer 작업 공간도 있다. 

CPU 보다 DISK가 훨씬 느리다 백만배 정도?


CPU 레지스터 - CPU 내부 저장 공간 

mode bit - 메모리에서 사용자 프로그램 스케줄링 처리 담당

## CPU는 Memory 와의 interaction ( 상호작용 ) 만 반복한다.

- 메모리에 있는 interaction 만 실행 반복한다.
- interaction 하나가 실행되고 나면 다음번에 실행할 interaction 즉, 기계어의 주소값이 증가하고 다음 사이클에서는 그다음 interaction을 실행하고를 반복

interrupt line - I/O device와 소통?

메모리와만 interaction을 주고받다가 scanf, printf 같이 IO device에서 값을 Output 하거나 Input 읽어와야하는 상황이 발생할 때 

CPU는 직접 IO device에 접근하지 않고 메모리와만 상호작용하다가

특정 프로그램에서 디스크 접근해야한다는 명령을 받게 되면, 디스크 컨트롤러에게 특정 데이터를 어딘가에서 읽어오라고 일을 시킴

디스크는 CPU 에서 요청 받아 device controller 가 하는 일

( data 를 가져오는 일? 등 ) 을 자신의 local buffer 에 저장해둠

CPU는 계속 돌아가야 하기 때문에 메모리 접근을 계속한다. 그 와중에 IO를 하게 되면 그 IO 는 CPU가 직접하지 않고, device controller에 시키고 계속 메모리와의 상호작용을 하게 된다.

한 프로그램에서 할일이 없으면 다른 프로그램으로 빠르게 옮겨가서 일을 처리한다. 

프로그램 간 빠르고 반복되는 처리를 하기 때문에 동시에 실행되는 것처럼 보임.

## TIMER

무한 루프를 도는 특정 프로그램을 만들어 실행할 경우 CPU는 계속 그 프로그램만 실행하는 데 사용되기 때문에 time sharing 이나 시분할이 불가능하다. 그래서 timer 하드웨어가 존재한다.

특정 프로그램이 CPU를 독점하지 못하도록 방지한다.

여러 프로그램이 실행되면 CPU는 각각의 프로그램에 CPU를 넘겨준다.

BUT, 그냥 넘겨주는 것이 아니라, timer 에게 값을 세팅한 후 넘겨주게된다. 

그럼 각각의 프로그램은 독점적으로 CPU 를 계속 쓸 수 있는 것이 아니라 timer 에 할당된 시간만큼만 CPU와 상호작용을 한다.
